package main

import (
	cw "TCellConsoleWrapper"
	astar "github.com/sidav/golibrl/astar"
	"strconv"
	"time"
)

func main() {
	cw.Init_console()
	defer cw.Close_console()
	//mymap := []string{
	//	" ####################",
	//	"    #       #       #",
	//	"# # ####### # #######",
	//	"# # #     # #       #",
	//	"# # # ### # ### ### #",
	//	"# #   #   #   # #   #",
	//	"####### ##### ### # #",
	//	"#       #         # #",
	//	"# ### ### ### ##### #",
	//	"#   # #   # # # #   #",
	//	"### # # # # # # # ###",
	//	"#   #   #   #   # # #",
	//	"# ############# # # #",
	//	"#     #   #     #   #",
	//	"### ### # # ##### ###",
	//	"# # #   #   #   # # #",
	//	"# # # ######### # # #",
	//	"#   #     #     # # #",
	//	"# ####### # ##### # #",
	//	"#   #   #       #   #",
	//	"### # # ####### # ###",
	//	"#   # # #       #   #",
	//	"# ### # #############",
	//	"# # # #   #     #   #",
	//	"# # # ### ##### # # #",
	//	"# #   # #   # #   # #",
	//	"# # ### ### # # ### #",
	//	"# #   #     # # # # #",
	//	"# ### # # ### # # # #",
	//	"#     # #       #   #",
	//	"####### ########### #",
	//	"#   #     #   #   # #",
	//	"# # ##### # # ### ###",
	//	"# #       # #   #   #",
	//	"# ############# ### #",
	//	"#   #         #     #",
	//	"### # # ##### ##### #",
	//	"# #   #   #       # #",
	//	"# ### ### # ####### #",
	//	"#     #   #         #",
	//	"####### #############",
	//	"#       #       #   #",
	//	"# ### # # ##### # ###",
	//	"#   # # # #     #   #",
	//	"### # # # # ####### #",
	//	"# # # # # # #   #   #",
	//	"# # # # # # # # # ###",
	//	"#   # #   #   # # # #",
	//	"##### ######### # # #",
	//	"# #   #       #   # #",
	//	"# # ### # ######### #",
	//	"# #     #     #     #",
	//	"# ########### # #####",
	//	"#             # #   #",
	//	"##### # ### ### ### #",
	//	"#   # #   #         #",
	//	"# # ##### ### # #####",
	//	"# #   # # #   #     #",
	//	"##### # # # ### #####",
	//	"#     #   # #   #   #",
	//	"# ######### # ### # #",
	//	"#           # #   # #",
	//	"### # ####### # ### #",
	//	"#   # #   # # # #   #",
	//	"# ##### # # # # ### #",
	//	"#       # # #     # #",
	//	"# ####### # ##### ###",
	//	"# #         #   #   #",
	//	"# ### ####### # ### #",
	//	"#   # # #   # # #   #",
	//	"### # # # ### ### # #",
	//	"#   #   #   #     # #",
	//	"# ######### ####### #",
	//	"#   #   # #       # #",
	//	"### ### # ####### # #",
	//	"# #     # #         #",
	//	"# ### ### # #########",
	//	"#     #         #   #",
	//	"# # ####### ### # # #",
	//	"# #       #   # # # #",
	//	"###################  ",
	//}
	mymap := []string{
		".########################",
		"....#.......#...#...#...#",
		"###.#.#####.#.#.#.#.###.#",
		"#...#...#.#...#...#.#...#",
		"#.#####.#.#########.#.###",
		"#.....#.#.....#.#.......#",
		"###.###.#####.#.#.#####.#",
		"#.......#...#.#...#...#.#",
		"#.#######.#.#.#####.###.#",
		"#.#.......#.#.#...#.....#",
		"#.#.#.#######.###.#####.#",
		"#...#.......#...........#",
		"#.#########.#########.###",
		"#.#...........#...#...#.#",
		"#.#.#########.###.#.###.#",
		"#.#.......#...#...#...#.#",
		"#.#######.#.###.#####.#.#",
		"#...#.....#.........#...#",
		"#####.#############.#####",
		"#.....#.......#...#.#...#",
		"#.#####.#.###.#.#.#.###.#",
		"#.......#.#...#.#.#.....#",
		"###.#####.#.#####.#######",
		"#...#.....#...#...#.....#",
		"#.###.#######.#.###.###.#",
		"#.#...#.....#...#...#...#",
		"#.#####.###.#####.#####.#",
		"#...#...#...#...#.#...#.#",
		"###.#.###.###.#.#.#.#.#.#",
		"#.....#...#...#.#...#.#.#",
		"###.###.#####.#.#####.#.#",
		"#...#...#.....#.#...#.#.#",
		"#.#####.#.#####.#.#.#.#.#",
		"#.#...#.#.#...#...#...#.#",
		"#.###.#.#.###.#####.###.#",
		"#.#...#.#...#.#.....#...#",
		"#.#.###.###.#.#.#####.###",
		"#...#.....#.#...#.....#.#",
		"#########.#.#####.#####.#",
		"#.........#.#.....#...#.#",
		"#.#########.#.#######.#.#",
		"#.#.........#.#...#...#.#",
		"#.#.#########.#.#.#.###.#",
		"#...#...#...#...#.#...#.#",
		"#.###.#.#.#.#####.#.#.#.#",
		"#...#.#.#.#.#...#...#.#.#",
		"###.#.#.#.#.#.#.#####.#.#",
		"#.#.#.#.#.#...#.#...#...#",
		"#.#.#.#.#.#####.#.#.#####",
		"#.#.#.#.#.#.....#.#.....#",
		"#.#.#.#.#.#.#####.#.###.#",
		"#...#.#.#.#.......#.#...#",
		"#.###.#.#.###########.###",
		"#...#.#.#.......#.....#.#",
		"###.###.#######.#.#####.#",
		"#...#...#.....#.#...#...#",
		"#.###.#.#.#.#.#.###.###.#",
		"#.....#...#.#.#.#.#.....#",
		"#.###########.#.#.###.###",
		"#.#...#.#.....#.#.#.....#",
		"#.#.#.#.#.#####.#.#.#.###",
		"#.#.#.#...#.#...#.#.#...#",
		"#.#.#.#.###.#.#.#.#.###.#",
		"#.#.#.#.....#.#...#...#.#",
		"#.#.#.#######.#.#####.#.#",
		"#...#.........#.#.....#.#",
		"###############.#.#####.#",
		"#...#...........#.#.....#",
		"#.###.###########.#.#####",
		"#.....#...........#.#...#",
		"#######.###########.###.#",
		"#.....#.#...#...#.#.....#",
		"#.###.#.#.#.#.#.#.#######",
		"#.#...#.#.#.#.#...#.....#",
		"#.#####.#.#.#.#####.###.#",
		"#.....#.#.#...#...#...#.#",
		"###.#.#.#.#####.#.###.#.#",
		"#...#...#...#...#...#.#.#",
		"#.#########.#.###.#.#.#.#",
		"#.#...#...#.#...#.#...#.#",
		"#.#.#.#.#.#.###.#####.###",
		"#.#.#.#.#.....#.....#...#",
		"#.#.#.#.###.#.#####.###.#",
		"#.#.#.#.#...#.....#...#.#",
		"#.#.#.###.#######.#####.#",
		"#...#.....#.....#.......#",
		"#####.#########.#######.#",
		"#.#...#...#...#.#.......#",
		"#.#.###.#.#.#.#.#.#######",
		"#...#...#.#.#...#.......#",
		"#####.###.#.###########.#",
		"#.....#.#.#...........#.#",
		"#.#####.#.#.#########.#.#",
		"#.#...#.....#...#...#...#",
		"#.###.###.#####.#.#######",
		"#...#.....#.#...#.......#",
		"###.#######.#.#########.#",
		"#.#.....#...#.#.........#",
		"#.#.#.#.#.#.#.#.#########",
		"#...#.#...#..............",
		"#########################",
	}
	costmap := getCostMapFromStringList(&mymap)
	key := ""
	fromx, fromy := 1, 1
	autoMove := false
	tox, toy := len(mymap) - 1, len(mymap[0]) - 1
	// textYCoord := len(mymap)+1
	for key != "ESCAPE" {
		cw.SetFgColor(cw.DARK_GRAY)
		startTime := time.Now()
		path := astar.FindPath(costmap, fromx, fromy, tox, toy, false, true, false)
		timetofindpath := int(time.Since(startTime) / time.Millisecond)
		for x := 0; x < len(mymap); x++ {
			for y := 0; y < len(mymap[0]); y++ {
				cw.PutChar(rune(mymap[x][y]), x, y)
			}
		}
		cw.SetFgColor(cw.MAGENTA)
		c := path
		for c != nil {
			pathx, pathy := c.X, c.Y
			cw.PutChar('*', pathx, pathy)
			offx, offy := c.GetNextStepVector()
			pathx += offx
			pathy += offy
			c = c.Child
		}
		cw.PutString("Time for pathfind: " + strconv.Itoa(timetofindpath) + "ms", 0, 24)
		cw.SetFgColor(cw.GREEN)
		cw.PutChar('@', fromx, fromy)
		cw.SetFgColor(cw.RED)
		cw.PutChar('X', tox, toy)
		if autoMove {
			offx, offy := path.GetNextStepVector()
			fromx += offx
			fromy += offy
			cw.PutString("AUTOMOVE IS ON", 0, 25)
		} else {
			cw.PutString("              ", 0, 25)
		}
		cw.Flush_console()
		time.Sleep(50 * time.Millisecond)
		key = cw.ReadKey()
		switch key {
		case "2":
			fromy += 1
		case "4":
			fromx -= 1
		case "8":
			fromy -= 1
		case "6":
			fromx += 1
		case "w":
			toy -= 1
		case "s":
			toy += 1
		case "a":
			tox -= 1
		case "d":
			tox += 1
		case " ":
			autoMove = !autoMove
		}
	}
}

func getCostMapFromStringList(strmap *[]string) *[][]int {
	width, height := len(*strmap), len((*strmap)[0])
	// cw.PutString(strconv.Itoa(width) + "x" + strconv.Itoa(height), 0, 22)
	costmap := make([][]int, width)
	for j := range costmap {
		costmap[j] = make([]int, height)
	}
	for i:=0; i<width; i++ {
		for j:=0; j<height; j++ {
			if (*strmap)[i][j] == '#' {
				costmap[i][j] = -1
			}
		}
	}
	//cw.PutString(strconv.Itoa(len(costmap)) + "x" + strconv.Itoa(len(costmap[0])), 0, 23)
	//cw.Flush_console()
	return &costmap
}

